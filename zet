#!/usr/bin/env bash

set -e

# colors
declare red="\e[1;31m"
declare yellow="\e[1;33m"
declare cyan="\e[1;36m"
declare reset="\e[0m"

# constants

declare -r ZET="$HOME/github.com/odas0r/zet"
declare -r FLEET="$ZET/fleet"
declare -r PERMANENT="$ZET/permanent"
declare -r HISTORY="$ZET/.history"
declare -r TEMPLATES="$ZET/.templates"

# TODO:
#
# [ ] ui
# [ ] ui <file>

x.help() {
  printf '
A personal zettelkasten program

Commands:                Alias  
  help                           Show help commands
  new                     <n>    Create a new zettel by giving it a title
  query                   <q>    Queries the all zettels with a full-text search panel
  query.fleet             <qf>   Full-text-search on the fleet zettels
  query.tags              <qt>   Prints all the tags that are being used, and
                                 select many to add to the query
  permanent               <p>    Transforms a fleet zettel into a permanent one
  link                    <l>    Links two zettels by showing the history or giving the 
                                 ids directly.
  tags                    <t>    Prints all the tags that are being used
  tags.edit               <te>   Prints all the tags that are being used, and
                                 replaces that tag globally
  tags.remove             <td>   Prints all the tags that are being used, and
                                 deletes that tag globally
  edit                    <e>    Edits a zettel by picking one from the history
  edit.last               <el>   Edits the last opened zettel
  ui                             Starts a server on bg so that you can preview your notes on a UI
  ui <file>                      Opens the current note on the ui server
  fix                     <f>    Renames the current zet from the # title
  history                 <f>    Shows the history of the opened zettels
  history.insert          <f>    Inserts the zettel into the history log file
  history.edit            <f>    Opens the editor on the history log file
'
}

x.new() {
  local ZETTEL_TEMPLATE="$TEMPLATES/zettel.tmpl.md"
  local title="$*"

  slug="$(echo "${title//\`/}" | slugify)"
  file="$slug.$(isosec).md"

  if [[ -z "$file" ]] || [[ -z "$title" ]]; then
    echo -e "\nError: invalid arguments"
    exit 1
  fi

  # change path to the fleet notes
  cd "$FLEET"

  # create a new zettel using the `tmpl` script
  export title
  tmpl "$ZETTEL_TEMPLATE" >"$file"

  nvr -s -l +3 "$file"
}

# Links two files.
#
# To understand the context of "linking":
#
# > On which note/context (file_one) would I like to find this current
# > note (file_two)?
x.link() {
  declare -A ids

  cd "$ZET"

  local counter=1
  while IFS="/" read -ra zettel; do
    type="${zettel[0]}"
    file="${zettel[1]}"

    filePath="$ZET/$type/$file"

    title=$(head -n 1 "$filePath")
    fileId="$(basename "$filePath" | cut -d '.' -f 2)"

    echo -e "$counter) $fileId $yellow$title$reset [${type}]"

    ids["$counter"]=$filePath

    ((counter++))
  done < <(tail -n30 "$HISTORY")

  read -r -p "Enter the zettels you want to link: " z1 z2

  fileOnePath=${ids["$z1"]}
  fileTwoPath=${ids["$z2"]}

  _validate_zettel "$fileOnePath"
  _validate_zettel "$fileTwoPath"

  if [[ "$fileOnePath" == "$fileTwoPath" ]]; then
    echo -e "\nError: you can't link the same zettel."
    exit 1
  fi

  fileOneTitle="$(head -n 1 "$fileOnePath")"
  fileOneLink="* [${fileOneTitle}](${fileOnePath})"

  # check if the link already exists
  fileOneID="$(basename "$fileOnePath" | cut -d '.' -f 2)"
  if grep -q "$fileOneID" "$fileTwoPath"; then
    echo -e "\nError: link already exists!"
    exit 1
  fi

  # add a \n if 'Links' is in the last line
  if [[ "$(tail -1 "$fileOnePath")" =~ "Links" ]]; then
    echo >>"$fileTwoPath"
  fi

  # Add the link
  echo "$fileOneLink" >>"$fileTwoPath"

  printf '
┌──▷ %s
│   
└─── %s

' "$fileOnePath" "$fileTwoPath"
}

# show all the previous files opened by querying + edit
# if no args
#
# if args find a file by that Id and open it
x.edit() {
  declare -A ids

  cd "$ZET"

  local counter=1
  while IFS="/" read -ra zettel; do
    type="${zettel[0]}"
    file="${zettel[1]}"

    filePath="$ZET/$type/$file"

    title=$(head -n 1 "$filePath")
    fileId="$(basename "$filePath" | cut -d '.' -f 2)"

    echo -e "$counter) $fileId $yellow$title$reset"

    ids["$counter"]=$filePath

    ((counter++))
  done < <(tail -n30 "$HISTORY")

  read -r -p "Which file do you want to edit?: " z1

  filePath=${ids["$z1"]}

  if [[ -z "$filePath" ]]; then
    echo -e "\nError: file doesn't exist"
    exit 1
  fi

  nvr -s -l "$filePath"
}

x.edit.last() {
  file=$(tail -1 "$HISTORY")

  cd "$ZET"

  nvr -s -l "$file"
}

x.permanent() {
  local file="$1"

  fileName="$(basename "$file")"

  # check if file is a zettel
  _validate_zettel "$file"

  if [[ -f "$PERMANENT/$fileName" ]]; then
    echo -e "\nError: zettel already is permanent"
    exit 1
  fi

  # move the file under /permanent
  mv "$FLEET/$fileName" "$PERMANENT/$fileName"

  # replace all the links with the old file path with the new one
  x.fix "$PERMANENT/$fileName"

  # open the new file
  tmux new-window -d nvr "$PERMANENT/$fileName"
}

x.remove() {
  local file="$1"

  # check if file is a zettel
  _validate_zettel "$file"

  zettelID="$(basename "$file" | cut -d '.' -f 2)"

  rm "$file"

  cd "$ZET"

  # remove old links
  while IFS=":" read -ra lines; do
    file="${lines[0]}"
    sed -i "/$zettelID/d" "$file"
  done < <(
    rg '^.*'"$zettelID"'.*$' "$FLEET" "$PERMANENT"
  )

  # clear the file from the history
  sed -i "/$zettelID/d" "$HISTORY"

  # open the query panel
  tmux new-window -d nvr -c "Telescope live_grep"
}

x.query() {
  cd "$PERMANENT"

  nvr -s -l -c "lua require('odas0r.telescope').search_zet_permanent({})"
}

x.query.fleet() {
  cd "$FLEET"

  nvr -s -l -c "lua require('odas0r.telescope').search_zet_fleet({})"
}

x.query.tags() {
  tmp=$(_get_tags)
  eval "declare -A tags=${tmp#*=}"

  echo -e "\n${yellow}Current Tags:$reset\n"

  for key in "${!tags[@]}"; do
    echo -e "$key) \e[3$((RANDOM * 6 / 32767 + 1))m${tags[$key]}$reset"
  done | sort -n

  # add \n
  echo

  read -r -p "Select tags to filter on search: " tagNrs

  local selectedTags
  for nr in $tagNrs; do
    selectedTags+="${tags[$nr]},"
  done

  # selectedTags=${1##*=}
  selectedTags=${selectedTags//#/\'#}
  selectedTags=${selectedTags//,/\',\'}
  selectedTags=${selectedTags//,\'/,}
  selectedTags=${selectedTags::-1}

  # echo "$selectedTags"

  nvr -s -l -c "lua require('odas0r.telescope').search_zet_fleet({$selectedTags})"
}

# Fix a given zettel file
#
# 1. Fix the current file basename regarding the # title
# 2. Fix all the link title and path associated with the current opened
#    zettel
x.fix() {
  local fileToFix="$1"

  # check if zettel id is valid
  _validate_zettel "$fileToFix"

  title=$(head -n 1 "$fileToFix")
  slug=$(echo "$title" | sed "s/# //" | sed "s/\`//" | slugify)
  fileId="$(basename "$fileToFix" | cut -d '.' -f 2)"
  newFileName=""

  # if invalid id, generate a new one
  if [[ ! $fileId =~ [0-9] ]]; then
    newFileName="$slug.$(isosec).md"
  else
    newFileName="${slug}.${fileId}.md"
  fi

  # get the zettel type (fleet or permanent)
  type=$(dirname "$(realpath "$fileToFix")")
  type="${type##*/}"

  oldFilePath="$ZET/$type/${fileToFix##*/}"
  newFilePath="$ZET/$type/$newFileName"

  newLink="* [${title//\`/}]($newFilePath)"

  # replace all oldLinks with newLinks
  while IFS=":" read -ra lines; do
    file="${lines[0]}"
    oldLink="${lines[1]}"

    perl -i -pe "s|\Q$oldLink\E|$newLink|g;" "$file"

    echo "Updated Link: $file"
  done < <(
    rg '^.*'"$fileId"'.*$' "$FLEET" "$PERMANENT"
  )

  # clear the file from the history (previously)
  sed -i "/$(basename "$fileToFix")/d" "$HISTORY"

  # update the filename if the file isn't the same
  if [[ "$oldFilePath" != "$newFilePath" ]]; then

    cat "$oldFilePath" >"$newFilePath"
    rm "$oldFilePath"

    # open the new file
    tmux new-window -d nvr "$newFilePath"
  fi

}

x.history() {
  local counter=1
  while IFS="/" read -ra zettel; do
    type="${zettel[0]}"
    file="${zettel[1]}"

    filePath="$ZET/$type/$file"

    title=$(head -n 1 "$filePath")
    fileId="$(basename "$filePath" | cut -d '.' -f 2)"

    echo -e "$fileId $yellow$title$reset"

    ((counter++))
  done <"$HISTORY"
}

x.history.edit() { nvr -s -l "$HISTORY"; }

x.history.insert() {
  local file="$1"

  _validate_zettel "$file"

  # if there's 30 zettels on history, delete the first one
  numberOfZettels=$(wc -l)
  if ((numberOfZettels == 30)); then
    tail -n +2 "$HISTORY" | sponge "$HISTORY"
  fi

  # get the zettel type (fleet or permanent)
  fileName=$(basename "$file")
  type=$(dirname "$(realpath "$file")")
  type="${type##*/}"

  # clear the file from the history (previously)
  sed -i "/$fileName/d" "$HISTORY"

  # append file to the history
  echo "$type/$fileName" >>"$HISTORY"
}

# Command: tags
#
# Pretty prints all tags that are currently in use
#
# Example: zet tags
x.tags() {
  tmp=$(_get_tags)
  eval "declare -A tags=${tmp#*=}"

  echo -e "\n${yellow}Current Tags:$reset\n"

  for key in "${!tags[@]}"; do
    echo -e "$key) \e[3$((RANDOM * 6 / 32767 + 1))m${tags[$key]}$reset"
  done | sort -n

  # add \n
  echo
}

# Command: tags.edit
#
# Pretty prints all tags that are currently in use and allows to input a
# replacement for a chosen tag. Every file that contains that tag will be
# modified.
#
# Example: zet tags.edit
x.tags.edit() {
  tmp=$(_get_tags)
  eval "declare -a tags=${tmp#*=}"

  echo -e "\n${yellow}current tags:$reset\n"

  for key in "${!tags[@]}"; do
    echo -e "$key) \e[3$((RANDOM * 6 / 32767 + 1))m${tags[$key]}$reset"
  done | sort -n

  # add \n
  echo

  read -r -p "Tag you want to edit: " tagNr
  read -r -p "New name: " newTag

  oldTag="${tags["$tagNr"]}"

  # format newtag
  newTag=${newTag// /}
  newTag=${newTag//#/}
  newTag="#$newTag"

  # seach and replace oldtag with newtag
  rg -w "$oldTag" "$FLEET" "$PERMANENT" -l |
    xargs -I@ sed -i "s/$oldTag/$newTag/g" @

  printf '\n%s\n\n' "Replaced tag $oldTag with $newTag!"
}

# Command: tags.remove
#
# Pretty prints all tags that are currently in use and allows to input a tag to
# be deleted. Every file that contains that tag will be modified.
#
# Example: zet tags.remove
x.tags.remove() {
  tmp=$(_get_tags)
  eval "declare -A tags=${tmp#*=}"

  echo -e "\n${yellow}Current Tags:$reset\n"

  for key in "${!tags[@]}"; do
    echo -e "$key) \e[3$((RANDOM * 6 / 32767 + 1))m${tags[$key]}$reset"
  done | sort -n

  # add \n
  echo

  read -r -p "Tag you want to delete: " tagNr

  oldTag="${tags["$tagNr"]}"

    # seach and replace oldtag with newtag
  rg -w "$oldTag" "$FLEET" "$PERMANENT" -l |
    xargs -I@ sed -i "s/$oldTag//g" @

  printf '\n%s\n\n' "Deleted $oldTag"
}

# --------------------- utility ---------------------

# validates a given zettel by checking his id, and file
_validate_zettel() {
  local file="$1"

  # get the zettel type (fleet or permanent)
  fileName=$(basename "$file")
  type=$(dirname "$(realpath "$file")")
  type="${type##*/}"

  # check if file is existent under fleet/ and permanent/
  if [[ ! -f "$ZET/$type/$fileName" ]] && [[ ! -f "$ZET/$type/$fileName" ]]; then
    echo -e "\nError: zettel does not exist."
    exit 1
  fi

  # check if zettel id is valid
  fileId="$(basename "$file" | cut -d '.' -f 2)"

  case $fileId in
  *[0-9]*) return ;;
  *)
    echo -e "\nError: invalid zettel id"
    exit 1
    ;;
  esac
}

_get_tags() {
  declare -A uniqueTags tags

  # get all tags and remove all repeated ones
  while IFS=":" read -ra lines; do
    tagArr="${lines[2]/ /}"

    for tag in $tagArr; do
      uniqueTags["$tag"]="$tag"
    done
  done < <(
    rg -e " #[a-zA-Z]" "$FLEET" "$PERMANENT"
  )

  # format the associative array with an array index
  local index=1
  for tag in "${uniqueTags[@]}"; do
    tags["$index"]=$tag
    ((index++))
  done

  # dump tags in shell reusable format
  declare -p tags
}

# --------------------- aliases ---------------------

_aliases() {
  local alias="$1"
  shift

  case $alias in
  "q")
    "x.query" "$@"
    exit $?
    ;;
  "qf")
    "x.query.fleet" "$@"
    exit $?
    ;;
  "qt")
    "x.query.tags" "$@"
    exit $?
    ;;
  "rm")
    "x.remove" "$@"
    exit $?
    ;;
  "n")
    "x.new" "$@"
    exit $?
    ;;
  "p")
    "x.permanent" "$@"
    exit $?
    ;;
  "e")
    "x.edit" "$@"
    exit $?
    ;;
  "f")
    "x.fix" "$@"
    exit $?
    ;;
  "ep")
    "x.edit.last" "$@"
    exit $?
    ;;
  "l")
    "x.link" "$@"
    exit $?
    ;;
  "t")
    "x.tags" "$@"
    exit $?
    ;;
  "te")
    "x.tags.edit" "$@"
    exit $?
    ;;
  "tr")
    "x.tags.remove" "$@"
    exit $?
    ;;
  esac
}

# --------------------- completion ---------------------

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=("${line##declare -f x.}")
done < <(declare -F)

mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }

  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

if [[ -n "$1" ]]; then
  declare CMD="$1"
  shift

  _aliases "$CMD" "$@"

  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$CMD" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi

x.help
