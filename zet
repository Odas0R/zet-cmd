#!/usr/bin/env bash

set -e

# colors
declare red="\e[1;31m"
declare yellow="\e[1;33m"
declare cyan="\e[1;36m"
declare reset="\e[0m"

# constants

declare -r ZET="$HOME/github.com/zet"
declare -r FLEET="$ZET/fleet"
declare -r PERMANENT="$ZET/permanent"

# TODO:
# [x] new
# [x] query
# [x] query.fleet
# [ ] list
# [ ] list.fleet
# [ ] list.perm
# [ ] permanent
# [ ] link
# [ ] edit
# [ ] edit.prev
# [ ] ui (starts a server on bg so that you can preview your notes)
# [ ] ui <file> (opens the current note on the browser)
# [ ] remove
# [ ] rename

x.help() {
  printf "
A personal zettelkasten program

Commands:
  help             Show help commands
  new              Create a new zettel by giving it a title
  query            Queries the zettels with Regex, you can filter by tags
  query.fleet      Queries the zettels with Regex, you can filter by tags
  list             Queries the zettels with Regex, you can filter by tags
  list.fleet       Queries the zettels with Regex, you can filter by tags
  permanent        Queries the zettels with Regex, you can filter by tags
  link             Links two zettels <id1> <id2>
  edit             Links two zettels <id1> <id2>
  edit.prev        Links two zettels <id1> <id2>
  ui               Starts a server on bg so that you can preview your notes
  ui <file>        Opens the current note on the ui server
  rename           Renames the current zet from the '# title'
"
}

x.new() {
  local ZETTEL_TEMPLATE="$ZET/.templates/zettel.tmpl.md"
  local title="$*"

  slug="$(echo "$title" | slugify)"
  file="$slug.$(isosec).md"

  if [[ -z "$file" ]] || [[ -z "$title" ]]; then
    echo "failed to create the zettel: invalid arguments"
    exit 1
  fi

  # change path to the fleet notes
  cd "$FLEET"

  # create a new zettel using the `tmpl` script
  export title
  tmpl "$ZETTEL_TEMPLATE" >"$file"

  nvr -s -l +3 "$file"
}

x.link() {
  declare keyword="$1"
  declare counter=1
  declare -A ids

  cd "$ZET"

  counter=1
  while IFS="/" read -ra zettel; do
    type="${zettel[0]}"
    file="${zettel[1]}"

    filePath="$type/$file"

    title=$(head -n 1 "$filePath")
    fileId="$(basename "$filePath" | cut -d '.' -f 2)"

    echo -e "$counter) $fileId $yellow$title$reset"

    ids["$counter"]=$file

    ((counter++))
  done < <(
    rg -l --ignore-case -m1 -w "$keyword" "permanent" "fleet"
  )

  read -r -p "Enter the zettels you want to link: " z1 z2

  fileOne=${ids["$z1"]}
  fileTwo=${ids["$z2"]}

  if [[ "$fileOne" == "$fileTwo" ]]; then
    echo "You can't link the same file."
    exit 1
  fi

  fileTwoTitle="$(head -n 1 "$fileTwo")"
  fileTwoLink="* [${fileTwoTitle### }](./${fileTwo})"

  # add a \n if 'Links' is in the last line
  if [[ "$(tail -1 "$fileOne")" =~ "Links" ]]; then
    echo >>"$fileOne"
  fi

  # Add the link
  echo "$fileTwoLink" >>"$fileOne"
}

# show all the previous files opened by querying + edit
# if no args
#
# if args find a file by that Id and open it
x.edit() {
  :
}

x.query() {
  nvr -s -l -c "cd $PERMANENT | lua require('odas0r.telescope').search_zet_permanent()"
}

x.query.fleet() {
  nvr -s -l -c "cd $FLEET | lua require('odas0r.telescope').search_zet_fleet()"
}

# TODO: Rename links as well
x.rename() {
  local oldFile="$1"

  if [[ ! -f "$oldFile" ]]; then
    echo "The given file was not valid."
    exit 1
  fi

  title=$(
    head -n 1 "$oldFile" |
      sed "s/# //" | slugify
  )
  fileId="$(basename "$oldFile" | cut -d '.' -f 2)"
  newFile="${title}.${fileId}.md"

  oldFilePath="$(realpath "$(dirname "$oldFile")")/$(basename "$oldFile")"
  newFilePath="$(realpath "$(dirname "$oldFile")")/$newFile"

  # create the new file
  cat "$oldFilePath" >"$newFilePath"
  # delete the old file
  rm "$oldFilePath"

  # rename all links

  tmux new-window -d nvr "$newFilePath"
}

# --------------------- utility ---------------------

# --------------------- aliases ---------------------

_aliases() {
  alias="$1"
  shift

  case $alias in
  "q")
    "x.query" "$@"
    exit $?
    ;;
  "qf")
    "x.query.fleet" "$@"
    exit $?
    ;;
  esac
}

# --------------------- completion ---------------------

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=("${line##declare -f x.}")
done < <(declare -F)

mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }

  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

if [[ -n "$1" ]]; then
  declare CMD="$1"
  shift

  _aliases "$CMD"

  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$CMD" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi

x.help
