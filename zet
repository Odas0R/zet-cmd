#!/usr/bin/env bash

# shellcheck disable=SC2155

set -e

# colors
declare red="\e[1;31m"
declare yellow="\e[1;33m"
declare cyan="\e[1;36m"
declare reset="\e[0m"

# constants

declare -r ZET="$HOME/github.com/odas0r/zet"
declare -r FLEET="$ZET/fleet"
declare -r PERMANENT="$ZET/permanent"
declare -r HISTORY="$ZET/.history"
declare -r TEMPLATES="$ZET/.templates"

# Log messages

declare -r DEBUG=0

declare -r ARGUMENTS_EMPTY="arguments cannot be empty"
declare -r FILE_NOT_EXIST="file does not exist"

declare -r ZETTEL_NOT_VALID="given zettel is not valid"
declare -r ZETTEL_ALREADY_PERMANENT="given zettel is already permanent"

declare -r LINK_ALREADY_EXISTS="link already exists"
declare -r CANNOT_LINK_SAME_ZETTEL="can't link the same zettel"

# TODO:
#
# [ ] ui
# [ ] ui <file>
#
# [ ] Generate a README for your commands
# [ ] Refactor your CLI
# [ ] Build a docker container to manage this cli

x.help() {
  printf '
A personal zettelkasten program

Commands:                Alias  
  help                           Show help commands
  new                     <n>    Create a new zettel by giving it a title
  query                   <q>    Queries the all zettels with a full-text search panel
  query.fleet             <qf>   Full-text-search on the fleet zettels
  query.tags              <qt>   Prints all the tags that are being used, and
                                 select many to add to the query
  permanent               <p>    Transforms a fleet zettel into a permanent one
  link                    <l>    Links two zettels by showing the history or giving the 
                                 ids directly.
  tags                    <t>    Prints all the tags that are being used
  tags.edit               <te>   Prints all the tags that are being used, and
                                 replaces that tag globally
  tags.remove             <td>   Prints all the tags that are being used, and
                                 deletes that tag globally
  edit                    <e>    Edits a zettel by picking one from the history
  edit.last               <el>   Edits the last opened zettel
  ui                             Starts a server on bg so that you can preview your notes on a UI
  ui <file>                      Opens the current note on the ui server
  fix                     <f>    Renames the current zet from the # title
  history                 <f>    Shows the history of the opened zettels
  history.insert          <f>    Inserts the zettel into the history log file
  history.edit            <f>    Opens the editor on the history log file
'
}

x.new() {
  local ZETTEL_TEMPLATE="$TEMPLATES/zettel.tmpl.md"
  local title="$*"

  slug="$(echo "${title//\`/}" | slugify)"
  file="$slug.$(isosec).md"

  if [[ -z "$file" ]] || [[ -z "$title" ]]; then
    _throwError "$ARGUMENTS_EMPTY"
  fi

  # change path to the fleet notes
  cd "$FLEET"

  # create a new zettel using the `tmpl` script
  export title
  tmpl "$ZETTEL_TEMPLATE" >"$file"

  nvr -s -l +3 "$file"
}

# Command: link
#
# Creates a [title](url) below the already existent links
#
# To understand linkage: "On what note/context (file_one) would I like to find
# this current note (file_two)?"
#
# Example: link
x.link() {

  cd "$ZET"

  local -a history=$(history.get)

  for key in "${!history[@]}"; do
    file=${history[$key]}
    basename=$(basename "$file")
    title=$(head -n 1 "$file")
    id="$(echo "$basename" | cut -d '.' -f 2)"

    echo -e "$key) [$id] $yellow$title$reset"
  done

  read -r -p "Enter the zettels you want to link: " optionOne optionTwo

  fileOnePath=${history["$optionOne"]}
  fileTwoPath=${history["$optionTwo"]}

  if [[ "$fileOnePath" == "$fileTwoPath" ]]; then
    _throwError "$CANNOT_LINK_SAME_ZETTEL"
  fi

  basename=$(basename "$fileOnePath")
  title=$(head -n 1 "$fileOnePath")
  id="$(echo "$basename" | cut -d '.' -f 2)"

  link="- [$title](${fileOnePath})"

  # check if the link already exists
  if grep -q "$id" "$fileTwoPath"; then
    _throwError "$LINK_ALREADY_EXISTS"
  fi

  # the following adds one line after Links
  sed -i "/Links/a\ \n${link}" "$fileTwoPath"

  printf '
┌──▷ %s
│   
└─── %s

' "$fileOnePath" "$fileTwoPath"
}

x.permanent() {
  local file="$1"

  if ! zettel.isValid "$file"; then
    _throwError "$ZETTEL_NOT_VALID"
  fi

  declare -A zettel=$(zettel.get "$file")

  basename=$(basename "$file")
  type=$(dirname "$(realpath "$file")")
  type="${type##*/}"

  if [[ $type == "permanent" ]]; then
    _throwError "$ZETTEL_ALREADY_PERMANENT"
  fi

  fleetPath="$FLEET/$basename"
  permanentPath="$PERMANENT/$basename"

  # move the file from fleet to permanent
  mv "$fleetPath" "$permanentPath"

  # replace all the links with the old file path with the new one
  x.fix "$permanentPath"

  # open the new file
  tmux new-window -d nvr "$permanentPath"
}

x.remove() {
  local file="$1"

  if ! zettel.isValid "$file"; then
    _throwError "$ZETTEL_NOT_VALID"
  fi

  basename=$(basename "$file")
  id="$(echo "$basename" | cut -d '.' -f 2)"

  rm -f "$file" && cd "$ZET"

  # remove old links
  while IFS=":" read -ra lines; do
    file="${lines[0]}"
    sed -i "/$id/d" "$file"
  done < <(
    rg '^.*'"$id"'.*$' "$FLEET" "$PERMANENT"
  )

  # clear the file from the history
  sed -i "/$id/d" "$HISTORY"

  # open the query panel
  tmux new-window -d nvr -c "bdelete | Telescope live_grep"
}

x.query() {
  cd "$PERMANENT"

  nvr -s -l -c "lua require('odas0r.telescope').search_zet_permanent({})"
}

x.query.fleet() {
  cd "$FLEET"

  nvr -s -l -c "lua require('odas0r.telescope').search_zet_fleet({})"
}

x.query.tags() {
  local -a tags=$(tag.get)

  echo -e "\n${yellow}Current Tags:$reset\n"

  for key in "${!tags[@]}"; do
    echo -e "$key) \e[3$((RANDOM * 6 / 32767 + 1))m${tags[$key]}$reset"
  done

  # add \n
  echo

  read -r -p "Select tags to filter on search: " tagNrs

  local selectedTags
  for nr in $tagNrs; do
    selectedTags+="${tags[$nr]},"
  done

  selectedTags=${selectedTags//#/\'#}
  selectedTags=${selectedTags//,/\',\'}
  selectedTags=${selectedTags//,\'/,}
  selectedTags=${selectedTags::-1}

  nvr -s -l -c "lua require('odas0r.telescope').search_zet({$selectedTags})"
}

# Fix a given zettel file
#
# 1. Fix the current file basename regarding the # title
# 2. Fix all the link title and path associated with the current opened
#    zettel
x.fix() {
  local fileToFix="$1"

  if ! zettel.isValid "$file"; then
    _throwError "$ZETTEL_NOT_VALID"
  fi

  # get the new zettel data
  title=$(head -n 1 "$fileToFix")
  slug=$(echo "$title" | sed "s/# //" | sed "s/\`//" | slugify)
  fileId="$(basename "$fileToFix" | cut -d '.' -f 2)"
  newFileName="${slug}.${fileId}.md"

  # get the zettel type (fleet or permanent)
  type=$(dirname "$(realpath "$fileToFix")")
  type="${type##*/}"

  oldFilePath="$ZET/$type/${fileToFix##*/}"
  newFilePath="$ZET/$type/$newFileName"

  newLink="* [${title//\`/}]($newFilePath)"

  # replace all oldLinks with newLinks
  while IFS=":" read -ra lines; do
    file="${lines[0]}"
    oldLink="${lines[1]}"

    perl -i -pe "s|\Q$oldLink\E|$newLink|g;" "$file"

    echo "Updated Link: $file"
  done < <(
    rg '^.*'"$fileId"'.*$' "$FLEET" "$PERMANENT"
  )

  # clear the file from the history (previously)
  sed -i "/$(basename "$fileToFix")/d" "$HISTORY"

  # update the filename if the file isn't the same
  if [[ "$oldFilePath" != "$newFilePath" ]]; then

    cat "$oldFilePath" >"$newFilePath"
    rm "$oldFilePath"

    # open the new file
    tmux new-window -d nvr "$newFilePath"
  fi
}

# show all the previous files opened by querying + edit
# if no args
#
# if args find a file by that Id and open it
x.edit() {
  cd "$ZET"

  local -a history=$(history.get)

  for key in "${!history[@]}"; do
    file=${history[$key]}
    basename=$(basename "$file")
    title=$(head -n 1 "$file")
    id="$(echo "$basename" | cut -d '.' -f 2)"

    echo -e "$key) [$id] $yellow$title$reset"
  done

  read -r -p "Which file do you want to edit?: " option

  selected=${history["$option"]}

  if [[ ! -f "$selected" ]]; then
    _throwError "$FILE_NOT_EXIST"
  fi

  nvr -s -l "$selected"
}

x.edit.last() {
  file=$(tail -1 "$HISTORY")

  cd "$ZET"

  nvr -s -l "$file"
}

x.history.edit() { nvr -s -l "$HISTORY"; }

x.history.insert() {
  local file="$1"

  if ! zettel.isValid "$file"; then
    _throwError "$ZETTEL_NOT_VALID"
  fi

  basename=$(basename "$file")
  id="$(echo "$basename" | cut -d '.' -f 2)"
  type=$(dirname "$(realpath "$file")")
  type="${type##*/}"


  # clear the file from the history (previously) if exists
  sed -i "/$id/d" "$HISTORY"

  # if there's 30 zettels on history, delete the first one
  numberOfZettels=$(wc -l "$HISTORY" | awk '{ print $1 }')

  if ((numberOfZettels == 30)); then
    # tail -n +2 "$HISTORY" | sponge "$HISTORY"
    sed -i '1d' "$HISTORY"
  fi

  # append file to the history
  echo "$type/$basename" >>"$HISTORY"
}

x.history() {
  local -a history=$(history.get)

  for key in "${!history[@]}"; do
    file=${history[$key]}
    basename=$(basename "$file")
    title=$(head -n 1 "$file")
    id="$(echo "$basename" | cut -d '.' -f 2)"

    echo -e "$key) [$id] $yellow$title$reset"
  done
}

# Command: tags
#
# Pretty prints all tags that are currently in use
#
# Example: zet tags
x.tags() {
  local -a tags=$(tag.get)

  echo -e "\n${yellow}Current Tags:$reset\n"

  for key in "${!tags[@]}"; do
    echo -e "$key) \e[3$((RANDOM * 6 / 32767 + 1))m${tags[$key]}$reset"
  done

  # add \n
  echo
}

# Command: tags.edit
#
# Pretty prints all tags that are currently in use and allows to input a
# replacement for a chosen tag. Every file that contains that tag will be
# modified.
#
# Example: zet tags.edit
x.tags.edit() {
  local -a tags=$(tag.get)

  echo -e "\n${yellow}Current tags:$reset\n"

  for key in "${!tags[@]}"; do
    echo -e "$key) \e[3$((RANDOM * 6 / 32767 + 1))m${tags[$key]}$reset"
  done

  # add \n
  echo

  read -r -p "Tag you want to edit: " tagNr
  read -r -p "New name: " newTag

  oldTag="${tags["$tagNr"]}"

  # format newtag
  newTag=${newTag// /}
  newTag=${newTag//#/}
  newTag="#$newTag"

  # seach and replace oldtag with newtag
  rg -w "$oldTag" "$FLEET" "$PERMANENT" -l |
    xargs -I@ sed -i "s/$oldTag/$newTag/g" @

  printf '\n%s\n\n' "Replaced tag \e[3$((RANDOM * 6 / 32767 + 1))m$oldTag$reset with \e[3$((RANDOM * 6 / 32767 + 1))m$newTag$reset!"
}

# Command: tags.remove
#
# Pretty prints all tags that are currently in use and allows to input a tag to
# be deleted. Every file that contains that tag will be modified.
#
# Example: zet tags.remove
x.tags.remove() {
  local -a tags=$(tag.get)

  echo -e "\n${yellow}Current Tags:$reset\n"

  for key in "${!tags[@]}"; do
    echo -e "$key) \e[3$((RANDOM * 6 / 32767 + 1))m${tags[$key]}$reset"
  done

  # add \n
  echo

  read -r -p "Tag you want to delete: " tagNr

  oldTag="${tags["$tagNr"]}"

  # seach and replace oldtag with newtag
  rg -w "$oldTag" "$FLEET" "$PERMANENT" -l |
    xargs -I@ sed -i "s/$oldTag//g" @

  printf '\n%s\n\n' "Deleted \e[3$((RANDOM * 6 / 32767 + 1))m$oldTag$reset"
}

# --------------------- zettel ---------------------

# isValid checks if a given zettel is valid by checking his id, and file,
# returns 0 if valid, 1 if not
zettel.isValid() {
  local file="$1"

  [[ -z "$file" ]] && _throwError "$ARGUMENTS_EMPTY"

  # get the zettel type (fleet or permanent)
  fileName=$(basename "$file")
  type=$(dirname "$(realpath "$file")")
  type="${type##*/}"

  # check if file is existent under fleet/ and permanent/
  if [[ ! -f "$FLEET/$fileName" ]] && [[ ! -f "$PERMANENT/$fileName" ]]; then
    return 1
  fi

  # check if zettel id is valid
  fileId="$(basename "$file" | cut -d '.' -f 2)"

  case $fileId in
  *[0-9]*) return 0 ;;
  *)
    return 1
    ;;
  esac

  return 0
}

# ------------------- history -------------------

history.get() {
  local -a history

  local counter=1
  while IFS="/" read -ra zettel; do
    type="${zettel[0]}"
    file="${zettel[1]}"

    filePath="$ZET/$type/$file"

    # insert the zettel into the history array
    history+=("$filePath")

    ((counter++))
  done <"$HISTORY"

  output=$(declare -p history)
  output=${output#*=}

  echo "${output[@]}"
}

# --------------------- tag ---------------------

tag.get() {
  local -A uniqueTags tags

  # get all tags and remove all repeated ones
  while IFS=":" read -ra lines; do
    tagArr="${lines[2]/ /}"

    for tag in $tagArr; do
      uniqueTags["$tag"]="$tag"
    done
  done < <(
    rg -e " #[a-zA-Z]" "$FLEET" "$PERMANENT"
  )

  # format the associative array with an array index
  local index=1
  for tag in "${uniqueTags[@]}"; do
    tags["$index"]=$tag
    ((index++))
  done

  # dump tags in shell reusable format
  output=$(declare -p tags)
  output=${output#*=}

  echo "${output[@]}"
}

# --------------------- utils ---------------------

_throwError() {
  local msg=$1

  if [[ -z "$msg" ]]; then
    echo -e "\n${red}Error:${reset} $ARGUMENTS_EMPTY \n"

    if $DEBUG; then
      _stacktrace
    fi

    exit 1
  fi

  echo -e "\n${red}Error:${reset} $msg \n"

  if $DEBUG; then
    _stacktrace
  fi

  exit 1
}

_stacktrace() {
  local i=0 size=${#BASH_SOURCE[@]}
  ((i < size)) && echo "STACKTRACE:"
  for (( ; i < size - 1; i++)); do
    ((frame = ${#BASH_SOURCE[@]} - i - 2))
    echo "[$frame] ${BASH_SOURCE[$i]:-}:${BASH_LINENO[$i]} ${FUNCNAME[$i + 1]}()"
  done

  # add \n
  echo
}

# --------------------- aliases ---------------------

_aliases() {
  local alias="$1"
  shift

  case $alias in
  "q")
    "x.query" "$@"
    exit $?
    ;;
  "qf")
    "x.query.fleet" "$@"
    exit $?
    ;;
  "qt")
    "x.query.tags" "$@"
    exit $?
    ;;
  "rm")
    "x.remove" "$@"
    exit $?
    ;;
  "n")
    "x.new" "$@"
    exit $?
    ;;
  "p")
    "x.permanent" "$@"
    exit $?
    ;;
  "e")
    "x.edit" "$@"
    exit $?
    ;;
  "f")
    "x.fix" "$@"
    exit $?
    ;;
  "ep")
    "x.edit.last" "$@"
    exit $?
    ;;
  "l")
    "x.link" "$@"
    exit $?
    ;;
  "t")
    "x.tags" "$@"
    exit $?
    ;;
  "te")
    "x.tags.edit" "$@"
    exit $?
    ;;
  "tr")
    "x.tags.remove" "$@"
    exit $?
    ;;
  esac
}

# --------------------- completion ---------------------

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ x\. ]] || continue
  COMMANDS+=("${line##declare -f x.}")
done < <(declare -F)

mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }

  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" ]] && echo "$c"
  done
  exit
fi

if [[ -n "$1" ]]; then
  declare CMD="$1"
  shift

  _aliases "$CMD" "$@"

  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$CMD" ]]; then
      "x.$CMD" "$@"
      exit $?
    fi
  done
fi

x.help
